use anyhow::{Context, Result};
use crossbeam_channel::{bounded, Receiver};
use hdrhistogram::Histogram;
use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::{self, Read};
use std::thread;

#[derive(Debug, Deserialize, Clone)]
struct Row {
    #[serde(rename = "timeStamp")]
    time_stamp: i64, // ms since epoch
    elapsed: u64, // response time ms
    label: String,
    #[serde(rename = "responseCode")]
    response_code: String,
    #[serde(rename = "responseMessage")]
    response_message: String,
    success: String,    // "true" / "false"
    bytes: Option<u64>, // received bytes
    #[serde(alias = "SentBytes", alias = "sentBytes")]
    sent_bytes: Option<u64>,
}

#[derive(serde::Serialize)]
struct OverallOut {
    samples: u64,
    failures: u64,
    error_pct: f64,
    avg_ms: f64,
    min_ms: u64,
    max_ms: u64,
    p50_ms: u64,
    p90_ms: u64,
    p95_ms: u64,
    p99_ms: u64,
    duration_sec: f64,
    tps: f64,
    kbps_recv: f64,
    kbps_sent: f64,
}

#[derive(serde::Serialize)]
struct LabelOut {
    label: String,
    count: u64,
    fails: u64,
    error_pct: f64,
    avg_ms: f64,
    min_ms: u64,
    max_ms: u64,
    p50_ms: u64,
    p90_ms: u64,
    p95_ms: u64,
    p99_ms: u64,
    tps: f64,
    kbps_recv: f64,
    kbps_sent: f64,
}

#[derive(serde::Serialize)]
struct ErrTypeOut {
    response_code: String,
    response_message: String,
    count: u64,
    pct_of_errors: f64,
    pct_of_samples: f64,
}

fn escape_html(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#39;")
}

fn render_html(
    overall: OverallOut,
    mut labels: Vec<LabelOut>,
    mut errs: Vec<ErrTypeOut>,
    title: &str,
) -> String {
    // keep largest labels first in charts
    labels.sort_by(|a, b| b.count.cmp(&a.count));
    // keep most frequent errors first
    errs.sort_by(|a, b| b.count.cmp(&a.count));

    let overall_json = serde_json::to_string(&overall).unwrap();
    let labels_json = serde_json::to_string(&labels).unwrap();
    let errs_json = serde_json::to_string(&errs).unwrap();

    format!(
        r#"
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>{title}</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
:root {{
  --bg: #0b1324;
  --fg: #e9eef7;
  --muted: #9aa8c7;
  --card: #121c34;
  --accent: #5aa9ff;
}}
* {{ box-sizing: border-box; }}
html,body {{ margin:0; padding:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }}
.container {{ max-width: 1200px; margin: 24px auto; padding: 0 16px; }}
h1,h2 {{ margin: 12px 0; }}
.grid {{ display:grid; gap:16px; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); }}
.card {{ background:var(--card); border-radius:14px; padding:16px; box-shadow: 0 2px 8px rgba(0,0,0,.25); }}
.metric {{ font-size: 32px; font-weight: 700; }}
.sub {{ color: var(--muted); font-size: 14px; }}
table {{ width:100%; border-collapse: collapse; }}
th, td {{ text-align:left; padding:8px 10px; border-bottom: 1px solid rgba(255,255,255,.08); }}
th {{ color: var(--muted); font-weight:600; }}
.badge {{ background: rgba(90,169,255,.18); color: #bfe0ff; padding:2px 8px; border-radius:999px; font-size:12px; }}
footer {{ color: var(--muted); margin: 24px 0; font-size: 13px; }}

/* Don't force a global canvas size; size via wrappers */
canvas {{ display:block; width:100% !important; height:100% !important; }}

/* Fixed-height wrappers for bar charts */
.chart-bar {{ height: 320px; }}

/* Square wrapper for the pie so it never stretches */
.chart-square {{
  width: 100%;
  max-width: 640px;   /* optional cap on huge screens */
  margin: 0 auto;     /* center in card */
  aspect-ratio: 1 / 1;
}}

/* Keep long error messages tame */
#tbl-errors td:nth-child(2) {{
  max-width: 520px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}}

@media (max-width: 640px) {{
  .chart-bar {{ height: 260px; }}
}}
</style>
</head>
<body>
<div class="container">
  <h1>JMeter .JTL Report</h1>
  <div class="sub">Generated by jtlstats — {title}</div>

  <div class="grid">
    <div class="card">
      <div class="sub">Total Samples</div>
      <div id="m-samples" class="metric">—</div>
    </div>
    <div class="card">
      <div class="sub">Failures</div>
      <div id="m-failures" class="metric">— <span class="badge" id="m-errorpct">—</span></div>
    </div>
    <div class="card">
      <div class="sub">Throughput (txn/sec)</div>
      <div id="m-tps" class="metric">—</div>
    </div>
    <div class="card">
      <div class="sub">KB/sec (recv / sent)</div>
      <div id="m-kbps" class="metric">—</div>
    </div>
  </div>

  <div class="grid" style="margin-top:16px;">
    <div class="card">
      <h2>Requests by Label</h2>
      <div class="chart-bar"><canvas id="chartCounts"></canvas></div>
    </div>
    <div class="card">
      <h2>Latency p95 by Label</h2>
      <div class="chart-bar"><canvas id="chartP95"></canvas></div>
    </div>
  </div>

  <div class="card" style="margin-top:16px;">
    <h2>Per-Label Details</h2>
    <div class="sub">Click a column header to sort (client-side).</div>
    <table id="tbl-labels">
      <thead>
        <tr>
          <th>Label</th>
          <th>Count</th>
          <th>Fails</th>
          <th>Error %</th>
          <th>Avg ms</th>
          <th>Min</th>
          <th>Max</th>
          <th>P50</th>
          <th>P90</th>
          <th>P95</th>
          <th>P99</th>
          <th>TPS</th>
          <th>KB/s recv</th>
          <th>KB/s sent</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- Pie chart in its own square container so it stays round -->
  <div class="card" style="margin-top:16px;">
    <h2>Error Types (Pie)</h2>
    <div class="chart-square"><canvas id="chartErrors"></canvas></div>
  </div>

  <!-- Error summary & table in separate card -->
  <div class="card" style="margin-top:16px;">
    <h2>Error Details</h2>
    <div id="error-summary" class="sub" style="margin-bottom:10px;">—</div>
    <table id="tbl-errors">
      <thead>
        <tr><th>Code</th><th>Message</th><th>Count</th><th>% of errors</th><th>% of samples</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <footer>Charts by Chart.js. This file is static — you can email or upload it anywhere.</footer>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {{
  const OVERALL = {overall_json};
  const LABELS  = {labels_json};
  const ERRORS  = {errs_json};

  const $ = id => document.getElementById(id);
  const setText = (id, v) => {{ const el = $(id); if (el) el.textContent = v; }};

  // --- metrics ---
  setText('m-samples', (OVERALL.samples ?? 0).toLocaleString());
  setText('m-failures', (OVERALL.failures ?? 0).toLocaleString());
  setText('m-errorpct', ((OVERALL.error_pct ?? 0) * 100).toFixed(2) + '%');
  setText('m-tps', (OVERALL.tps ?? 0).toFixed(3));
  setText('m-kbps', (OVERALL.kbps_recv ?? 0).toFixed(2) + ' / ' + (OVERALL.kbps_sent ?? 0).toFixed(2));

  // --- per-label table ---
  function td(v) {{
    const d = document.createElement('td');
    d.textContent = (typeof v === 'number') ? v.toLocaleString() : (v ?? '');
    return d;
  }}
  const tbodyL = document.querySelector('#tbl-labels tbody');
  if (tbodyL && Array.isArray(LABELS)) {{
    LABELS.forEach(L => {{
      const tr = document.createElement('tr');
      tr.append(td(L.label));
      tr.append(td(L.count));
      tr.append(td(L.fails));
      tr.append(td(((L.error_pct ?? 0) * 100).toFixed(2) + '%'));
      tr.append(td((L.avg_ms ?? 0).toFixed(2)));
      tr.append(td(L.min_ms ?? 0));
      tr.append(td(L.max_ms ?? 0));
      tr.append(td(L.p50_ms ?? 0));
      tr.append(td(L.p90_ms ?? 0));
      tr.append(td(L.p95_ms ?? 0));
      tr.append(td(L.p99_ms ?? 0));
      tr.append(td((L.tps ?? 0).toFixed(3)));
      tr.append(td((L.kbps_recv ?? 0).toFixed(3)));
      tr.append(td((L.kbps_sent ?? 0).toFixed(3)));
      tbodyL.append(tr);
    }});
  }}

  // --- error summary + table ---
  const totalErrors = (ERRORS || []).reduce((a, e) => a + (e.count || 0), 0);
  const errRate = OVERALL.error_pct ? (OVERALL.error_pct * 100).toFixed(2) : '0.00';
  const summary = `Total errors: ${{totalErrors.toLocaleString()}}  •  Error rate: ${{errRate}}%  •  Samples: ${{(OVERALL.samples||0).toLocaleString()}}`;
  const sumEl = $('error-summary'); if (sumEl) sumEl.textContent = summary;

  const tbodyE = document.querySelector('#tbl-errors tbody');
  if (tbodyE && Array.isArray(ERRORS)) {{
    ERRORS.forEach(E => {{
      const tr = document.createElement('tr');
      tr.append(td(E.response_code));
      tr.append(td(E.response_message));
      tr.append(td(E.count));
      tr.append(td((E.pct_of_errors ?? 0).toFixed(2) + '%'));
      tr.append(td((E.pct_of_samples ?? 0).toFixed(2) + '%'));
      tbodyE.append(tr);
    }});
  }}

  // --- charts ---
  function withChartJs(cb) {{
    if (window.Chart) cb();
    else setTimeout(() => withChartJs(cb), 50);
  }}

  withChartJs(() => {{
    const labels = (LABELS || []).map(x => x.label);
    const countData = (LABELS || []).map(x => x.count);
    const failData  = (LABELS || []).map(x => x.fails);
    const p95Data   = (LABELS || []).map(x => x.p95_ms);
    const errTop    = (ERRORS || []).slice(0, 10);
    const errNames  = errTop.map(e => `${{e.response_code}} ${{e.response_message}}`);
    const errCounts = errTop.map(e => e.count);

    const elCounts = $('chartCounts');
    const elP95    = $('chartP95');
    const elErrors = $('chartErrors');

    if (elCounts) new Chart(elCounts, {{
      type: 'bar',
      data: {{ labels, datasets: [{{ label: 'Count', data: countData }}, {{ label: 'Failures', data: failData }}] }},
      options: {{
        responsive: true,
        maintainAspectRatio: false,   // fill .chart-bar height
        plugins: {{ legend: {{ labels: {{ color: '#cfe3ff' }} }} }},
        scales: {{ x: {{ ticks: {{ color: '#cfe3ff' }} }}, y: {{ ticks: {{ color: '#cfe3ff' }} }} }}
      }}
    }});

    if (elP95) new Chart(elP95, {{
      type: 'bar',
      data: {{ labels, datasets: [{{ label: 'p95 (ms)', data: p95Data }}] }},
      options: {{
        responsive: true,
        maintainAspectRatio: false,   // fill .chart-bar height
        plugins: {{ legend: {{ labels: {{ color: '#cfe3ff' }} }} }},
        scales: {{ x: {{ ticks: {{ color: '#cfe3ff' }} }}, y: {{ ticks: {{ color: '#cfe3ff' }} }} }}
      }}
    }});

    if (elErrors) new Chart(elErrors, {{
      type: 'pie',
      data: {{ labels: errNames, datasets: [{{ label: 'Errors (top 10)', data: errCounts }}] }},
      options: {{
        responsive: true,
        maintainAspectRatio: false,   // fills the square wrapper => perfect circle
        plugins: {{ legend: {{ position: 'right', labels: {{ color: '#cfe3ff' }} }} }}
      }}
    }});
  }});
}});
</script>

</body>
</html>
"#,
        title = escape_html(title),
        overall_json = overall_json,
        labels_json = labels_json,
        errs_json = errs_json
    )
}

#[derive(Clone)]
struct Agg {
    count: u64,
    fails: u64,
    recv_bytes: u128,
    sent_bytes: u128,
    first_ts: i64,
    last_ts: i64,
    hist: Histogram<u64>,
    min_elapsed: u64,
    max_elapsed: u64,
}

impl Agg {
    fn new() -> Self {
        let hist = Histogram::<u64>::new_with_bounds(1, 86_400_000, 3).unwrap();
        Self {
            count: 0,
            fails: 0,
            recv_bytes: 0,
            sent_bytes: 0,
            first_ts: i64::MAX,
            last_ts: i64::MIN,
            hist,
            min_elapsed: u64::MAX,
            max_elapsed: 0,
        }
    }
    fn add(&mut self, r: &Row) {
        self.count += 1;
        if !r.success.eq_ignore_ascii_case("true") {
            self.fails += 1;
        }
        let _ = self.hist.record(r.elapsed.max(1)); // avoid zero
        if r.elapsed < self.min_elapsed {
            self.min_elapsed = r.elapsed;
        }
        if r.elapsed > self.max_elapsed {
            self.max_elapsed = r.elapsed;
        }
        if let Some(b) = r.bytes {
            self.recv_bytes += b as u128;
        }
        if let Some(sb) = r.sent_bytes {
            self.sent_bytes += sb as u128;
        }
        if r.time_stamp < self.first_ts {
            self.first_ts = r.time_stamp;
        }
        if r.time_stamp > self.last_ts {
            self.last_ts = r.time_stamp;
        }
    }
    fn merge(&mut self, other: Agg) {
        self.count += other.count;
        self.fails += other.fails;
        self.recv_bytes += other.recv_bytes;
        self.sent_bytes += other.sent_bytes;
        self.first_ts = self.first_ts.min(other.first_ts);
        self.last_ts = self.last_ts.max(other.last_ts);
        self.min_elapsed = self.min_elapsed.min(other.min_elapsed);
        self.max_elapsed = self.max_elapsed.max(other.max_elapsed);
        self.hist.add(&other.hist).unwrap();
    }
    fn duration_secs(&self) -> f64 {
        if self.first_ts == i64::MAX || self.last_ts <= self.first_ts {
            return 0.0;
        }
        (self.last_ts - self.first_ts) as f64 / 1000.0
    }
    fn avg_ms(&self) -> f64 {
        self.hist.mean()
    }
    fn q(&self, p: f64) -> u64 {
        self.hist.value_at_quantile(p)
    }
}
impl Default for Agg {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Default)]
struct Shard {
    overall: Agg,
    per_label: HashMap<String, Agg>,
    error_types: HashMap<(String, String), u64>,
}

impl Shard {
    fn new() -> Self {
        Self {
            overall: Agg::new(),
            per_label: HashMap::new(),
            error_types: HashMap::new(),
        }
    }
    fn add(&mut self, r: &Row) {
        if !r.success.eq_ignore_ascii_case("true") {
            *self
                .error_types
                .entry((r.response_code.clone(), r.response_message.clone()))
                .or_default() += 1;
        }
        self.overall.add(r);
        self.per_label
            .entry(r.label.clone())
            .or_insert_with(Agg::new)
            .add(r);
    }
    fn merge(&mut self, other: Shard) {
        self.overall.merge(other.overall);
        for (k, v) in other.per_label {
            self.per_label
                .entry(k)
                .and_modify(|agg| agg.merge(v.clone()))
                .or_insert(v);
        }
        for (k, v) in other.error_types {
            *self.error_types.entry(k).or_default() += v;
        }
    }
}

enum Msg {
    Batch(Vec<Row>),
    End,
}

fn reader_thread(
    mut rdr: csv::Reader<Box<dyn Read + Send>>,
    tx: crossbeam_channel::Sender<Msg>,
    batch_size: usize,
) -> Result<()> {
    let mut batch = Vec::with_capacity(batch_size);
    for rec in rdr.deserialize::<Row>() {
        match rec {
            Ok(row) => {
                batch.push(row);
                if batch.len() >= batch_size {
                    tx.send(Msg::Batch(std::mem::take(&mut batch))).ok();
                }
            }
            Err(e) => {
                eprintln!("Skipping bad row: {e}");
            }
        }
    }
    if !batch.is_empty() {
        tx.send(Msg::Batch(batch)).ok();
    }
    tx.send(Msg::End).ok();
    Ok(())
}

fn worker_thread(rx: Receiver<Msg>) -> Shard {
    let mut shard = Shard::new();
    loop {
        match rx.recv() {
            Ok(Msg::Batch(rows)) => {
                for r in rows.iter() {
                    shard.add(r);
                }
            }
            Ok(Msg::End) | Err(_) => break,
        }
    }
    shard
}

fn kbps(bytes: u128, secs: f64) -> f64 {
    if secs <= 0.0 {
        0.0
    } else {
        (bytes as f64 / 1024.0) / secs
    }
}

fn open_reader(path: Option<&str>, delim: u8) -> Result<csv::Reader<Box<dyn Read + Send>>> {
    let boxed: Box<dyn Read + Send> = match path {
        Some("-") | None => Box::new(io::stdin()),
        Some(p) => Box::new(File::open(p).with_context(|| format!("open {p}"))?),
    };
    Ok(csv::ReaderBuilder::new()
        .delimiter(delim)
        .has_headers(true)
        .from_reader(boxed))
}

fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();
    let input_path = args.get(1).map(|s| s.as_str());
    let delim = args.get(2).map(|s| s.as_bytes()[0]).unwrap_or(b',');
    let threads = num_cpus::get();

    let rdr = open_reader(input_path, delim)?;
    let (tx, rx) = bounded::<Msg>(threads * 2);

    let mut workers = Vec::with_capacity(threads);
    for _ in 0..threads {
        let rx_c = rx.clone();
        workers.push(thread::spawn(move || worker_thread(rx_c)));
    }

    let batch_size = 50_000;
    let tx_c = tx.clone();
    let reader_handle = thread::spawn(move || reader_thread(rdr, tx_c, batch_size));

    drop(tx);

    let mut total = Shard::new();
    for w in workers {
        let shard = w.join().expect("worker panicked");
        total.merge(shard);
    }
    reader_handle.join().expect("reader panicked")?;

    let overall = &total.overall;

    let dur = overall.duration_secs();
    let tps = if dur > 0.0 {
        overall.count as f64 / dur
    } else {
        0.0
    };
    let overall_out = OverallOut {
        samples: overall.count,
        failures: overall.fails,
        error_pct: if overall.count == 0 {
            0.0
        } else {
            overall.fails as f64 / overall.count as f64
        },
        avg_ms: overall.avg_ms(),
        min_ms: if overall.min_elapsed == u64::MAX {
            0
        } else {
            overall.min_elapsed
        },
        max_ms: overall.max_elapsed,
        p50_ms: overall.q(0.50),
        p90_ms: overall.q(0.90),
        p95_ms: overall.q(0.95),
        p99_ms: overall.q(0.99),
        duration_sec: dur,
        tps,
        kbps_recv: kbps(overall.recv_bytes, dur),
        kbps_sent: kbps(overall.sent_bytes, dur),
    };

    let labels_out: Vec<LabelOut> = total
        .per_label
        .into_iter()
        .map(|(label, agg)| {
            let dur = agg.duration_secs();
            let tps = if dur > 0.0 {
                agg.count as f64 / dur
            } else {
                0.0
            };
            LabelOut {
                label,
                count: agg.count,
                fails: agg.fails,
                error_pct: if agg.count == 0 {
                    0.0
                } else {
                    agg.fails as f64 / agg.count as f64
                },
                avg_ms: agg.avg_ms(),
                min_ms: if agg.min_elapsed == u64::MAX {
                    0
                } else {
                    agg.min_elapsed
                },
                max_ms: agg.max_elapsed,
                p50_ms: agg.q(0.50),
                p90_ms: agg.q(0.90),
                p95_ms: agg.q(0.95),
                p99_ms: agg.q(0.99),
                tps,
                kbps_recv: kbps(agg.recv_bytes, dur),
                kbps_sent: kbps(agg.sent_bytes, dur),
            }
        })
        .collect();

    let total_errors: u64 = total.error_types.values().sum();
    let errs_out: Vec<ErrTypeOut> = {
        let mut v: Vec<_> = total.error_types.into_iter().collect();
        v.sort_by(|a, b| b.1.cmp(&a.1));
        v.into_iter()
            .map(|((code, msg), cnt)| ErrTypeOut {
                response_code: code,
                response_message: msg,
                count: cnt,
                pct_of_errors: if total_errors == 0 {
                    0.0
                } else {
                    (cnt as f64 / total_errors as f64) * 100.0
                },
                pct_of_samples: if overall.count == 0 {
                    0.0
                } else {
                    (cnt as f64 / overall.count as f64) * 100.0
                },
            })
            .collect()
    };

    let out_path = args.get(3).map(|s| s.as_str()).unwrap_or("jtl_report.html");
    let title = input_path.unwrap_or("stdin");
    let html = render_html(overall_out, labels_out, errs_out, title);
    std::fs::write(out_path, html).with_context(|| format!("write {}", out_path))?;

    println!("Wrote HTML report to {}", out_path);

    Ok(())
}
